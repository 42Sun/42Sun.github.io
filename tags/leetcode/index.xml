<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on 孙丁一的博客</title>
    <link>https://sundingyi.com/tags/leetcode/</link>
    <description>Recent content in LeetCode on 孙丁一的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 30 May 2021 19:56:20 +0800</lastBuildDate><atom:link href="https://sundingyi.com/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>每日LeetCode 187-188</title>
      <link>https://sundingyi.com/blog/101/</link>
      <pubDate>Sun, 30 May 2021 19:56:20 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/101/</guid>
      <description>187 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 输入：</description>
    </item>
    
    <item>
      <title>每日LeetCode 185-186</title>
      <link>https://sundingyi.com/blog/100/</link>
      <pubDate>Fri, 28 May 2021 22:15:31 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/100/</guid>
      <description>185 输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例: 输入：s = &amp;ldquo;abc&amp;rdquo; 输出：[&amp;ld</description>
    </item>
    
    <item>
      <title>每日LeetCode 183-184</title>
      <link>https://sundingyi.com/blog/99/</link>
      <pubDate>Thu, 27 May 2021 22:20:28 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/99/</guid>
      <description>183 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 来源</description>
    </item>
    
    <item>
      <title>每日LeetCode 181-182</title>
      <link>https://sundingyi.com/blog/98/</link>
      <pubDate>Wed, 26 May 2021 21:50:55 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/98/</guid>
      <description>181 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不</description>
    </item>
    
    <item>
      <title>每日LeetCode 179-180</title>
      <link>https://sundingyi.com/blog/97/</link>
      <pubDate>Mon, 24 May 2021 21:47:48 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/97/</guid>
      <description>179 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: MinStack minStack =</description>
    </item>
    
    <item>
      <title>每日LeetCode 178</title>
      <link>https://sundingyi.com/blog/96/</link>
      <pubDate>Tue, 18 May 2021 22:00:11 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/96/</guid>
      <description>178 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / 2 2 / \ / 3 4 4</description>
    </item>
    
    <item>
      <title>每日LeetCode 176-177</title>
      <link>https://sundingyi.com/blog/95/</link>
      <pubDate>Sun, 16 May 2021 19:28:47 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/95/</guid>
      <description>176 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:</description>
    </item>
    
    <item>
      <title>每日LeetCode 173-175</title>
      <link>https://sundingyi.com/blog/94/</link>
      <pubDate>Sat, 15 May 2021 13:00:04 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/94/</guid>
      <description>173 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例： 输入：nums =</description>
    </item>
    
    <item>
      <title>每日LeetCode 171-172</title>
      <link>https://sundingyi.com/blog/93/</link>
      <pubDate>Fri, 14 May 2021 20:55:53 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/93/</guid>
      <description>171 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1: 输入: n = 1 输出: [1,2,3,4,5,6,7,8,9] 来源：</description>
    </item>
    
    <item>
      <title>每日LeetCode 169-170</title>
      <link>https://sundingyi.com/blog/92/</link>
      <pubDate>Thu, 13 May 2021 21:25:28 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/92/</guid>
      <description>169 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入</description>
    </item>
    
    <item>
      <title>每日LeetCode 166-168</title>
      <link>https://sundingyi.com/blog/91/</link>
      <pubDate>Tue, 11 May 2021 17:18:07 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/91/</guid>
      <description>166 09 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素</description>
    </item>
    
    <item>
      <title>每日LeetCode 163-165</title>
      <link>https://sundingyi.com/blog/90/</link>
      <pubDate>Mon, 10 May 2021 15:58:03 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/90/</guid>
      <description>163 剑指offer 05 请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。 示例 1： 输入：s = &amp;ldquo;We are happy.&amp;rdquo; 输出：&amp;ldquo;W</description>
    </item>
    
    <item>
      <title>每日LeetCode 160-162</title>
      <link>https://sundingyi.com/blog/89/</link>
      <pubDate>Sat, 08 May 2021 17:46:42 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/89/</guid>
      <description>160 (剑指 offer 11) 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如</description>
    </item>
    
    <item>
      <title>每日LeetCode 158-159</title>
      <link>https://sundingyi.com/blog/88/</link>
      <pubDate>Fri, 07 May 2021 19:47:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/88/</guid>
      <description>158 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： &#39;A&#39; -&amp;gt; 1 &#39;B&#39; -&amp;gt; 2 ... &#39;Z&#39; -&amp;gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有</description>
    </item>
    
    <item>
      <title>每日LeetCode 156-157</title>
      <link>https://sundingyi.com/blog/87/</link>
      <pubDate>Thu, 06 May 2021 15:43:02 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/87/</guid>
      <description>156 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构</description>
    </item>
    
    <item>
      <title>每日LeetCode 152-155</title>
      <link>https://sundingyi.com/blog/86/</link>
      <pubDate>Wed, 05 May 2021 20:18:34 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/86/</guid>
      <description>152 给定两个整数 n 和 k，返回 1 &amp;hellip; n 中所有可能的 k 个数的组合。 示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(int n, int k) { getCombine(n, k, 1,</description>
    </item>
    
    <item>
      <title>每日LeetCode 151</title>
      <link>https://sundingyi.com/blog/85/</link>
      <pubDate>Tue, 04 May 2021 19:57:03 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/85/</guid>
      <description>151 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的</description>
    </item>
    
    <item>
      <title>每日LeetCode 150</title>
      <link>https://sundingyi.com/blog/84/</link>
      <pubDate>Mon, 03 May 2021 21:07:11 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/84/</guid>
      <description>150 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题</description>
    </item>
    
    <item>
      <title>每日LeetCode 149</title>
      <link>https://sundingyi.com/blog/149/</link>
      <pubDate>Sun, 02 May 2021 20:24:36 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/149/</guid>
      <description>149 给定一个 *m* x *n* 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法**。** 进阶： 一个直观的解决方案是使用 O(*m**n*) 的额外</description>
    </item>
    
    <item>
      <title>每日LeetCode 148</title>
      <link>https://sundingyi.com/blog/82/</link>
      <pubDate>Sat, 01 May 2021 20:20:03 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/82/</guid>
      <description>148 给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 **说明：**每次只能向下或者向右移动一</description>
    </item>
    
    <item>
      <title>每日LeetCode 147</title>
      <link>https://sundingyi.com/blog/81/</link>
      <pubDate>Fri, 30 Apr 2021 21:21:09 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/81/</guid>
      <description>147 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角</description>
    </item>
    
    <item>
      <title>每日LeetCode 146</title>
      <link>https://sundingyi.com/blog/80/</link>
      <pubDate>Thu, 29 Apr 2021 20:08:24 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/80/</guid>
      <description>146 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角</description>
    </item>
    
    <item>
      <title>每日LeetCode 143-145</title>
      <link>https://sundingyi.com/blog/79/</link>
      <pubDate>Wed, 28 Apr 2021 17:01:21 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/79/</guid>
      <description>143 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。 如果不能形成任何面积不为零的三角形，返回 0</description>
    </item>
    
    <item>
      <title>每日LeetCode 140-142</title>
      <link>https://sundingyi.com/blog/78/</link>
      <pubDate>Sat, 24 Apr 2021 22:48:43 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/78/</guid>
      <description>140 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以</description>
    </item>
    
    <item>
      <title>每日LeetCode 137-139</title>
      <link>https://sundingyi.com/blog/77/</link>
      <pubDate>Fri, 23 Apr 2021 20:33:00 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/77/</guid>
      <description>137 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 class Solution { int pre; int ans; public int minDiffInBST(TreeNode root) { ans = Integer.MAX_VALUE; pre = -1; dfs(root); return ans; } public void dfs(TreeNode root ){ if (root == null) { return; }</description>
    </item>
    
    <item>
      <title>每日LeetCode 133-136</title>
      <link>https://sundingyi.com/blog/76/</link>
      <pubDate>Wed, 21 Apr 2021 15:50:13 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/76/</guid>
      <description>133 给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。 重复出现的子串要计算它</description>
    </item>
    
    <item>
      <title>每日LeetCode 130-132</title>
      <link>https://sundingyi.com/blog/75/</link>
      <pubDate>Mon, 19 Apr 2021 21:03:25 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/75/</guid>
      <description>130 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节</description>
    </item>
    
    <item>
      <title>每日LeetCode 126-129</title>
      <link>https://sundingyi.com/blog/74/</link>
      <pubDate>Sun, 18 Apr 2021 13:37:03 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/74/</guid>
      <description>126 给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果</description>
    </item>
    
    <item>
      <title>每日LeetCode 122-125</title>
      <link>https://sundingyi.com/blog/72/</link>
      <pubDate>Sat, 17 Apr 2021 12:22:17 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/72/</guid>
      <description>122 你和你的朋友，两个人一起玩 Nim 游戏： 桌子上有一堆石头。 你们轮流进行自己的回合，你作为先手。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石</description>
    </item>
    
    <item>
      <title>每日LeetCode 118-121</title>
      <link>https://sundingyi.com/blog/71/</link>
      <pubDate>Fri, 16 Apr 2021 19:05:10 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/71/</guid>
      <description>118 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 示例 1： 输入： 3 / \ 9 20 / \ 15 7 输出：[3, 14.5, 11] 解释： 第 0 层的平均值是 3 , 第1层是</description>
    </item>
    
    <item>
      <title>每日LeetCode 114-117</title>
      <link>https://sundingyi.com/blog/69/</link>
      <pubDate>Thu, 15 Apr 2021 14:04:46 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/69/</guid>
      <description>114 假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索</description>
    </item>
    
    <item>
      <title>每日LeetCode 110-113</title>
      <link>https://sundingyi.com/blog/68/</link>
      <pubDate>Wed, 14 Apr 2021 19:20:12 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/68/</guid>
      <description>110 给定一个 N 叉树，返回其节点值的 后序遍历 。 N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 递归 class Solution { public List&amp;lt;Integer&amp;gt; postorder(Node root) {</description>
    </item>
    
    <item>
      <title>每日LeetCode 107-109</title>
      <link>https://sundingyi.com/blog/67/</link>
      <pubDate>Mon, 12 Apr 2021 21:23:10 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/67/</guid>
      <description>107 你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。 给定一个数字 n，找出可形成完整阶梯行的总行数。 n 是一个非负整数</description>
    </item>
    
    <item>
      <title>每日LeetCode 103-106</title>
      <link>https://sundingyi.com/blog/66/</link>
      <pubDate>Sun, 11 Apr 2021 18:11:56 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/66/</guid>
      <description>103 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结</description>
    </item>
    
    <item>
      <title>每日LeetCode 99-102</title>
      <link>https://sundingyi.com/blog/65/</link>
      <pubDate>Sat, 10 Apr 2021 18:52:18 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/65/</guid>
      <description>99 给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符： &amp;lsquo;A&amp;rsquo; : Absent，缺勤 &amp;lsquo;L&amp;rsquo; : Late，迟到 &amp;lsquo;P&amp;rsquo; : Present，到场 如果一</description>
    </item>
    
    <item>
      <title>每日LeetCode 94-98</title>
      <link>https://sundingyi.com/blog/64/</link>
      <pubDate>Fri, 09 Apr 2021 20:03:17 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/64/</guid>
      <description>94 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入</description>
    </item>
    
    <item>
      <title>每日LeetCode 88-93</title>
      <link>https://sundingyi.com/blog/63/</link>
      <pubDate>Thu, 08 Apr 2021 20:12:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/63/</guid>
      <description>88 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) =</description>
    </item>
    
    <item>
      <title>每日LeetCode 83-87</title>
      <link>https://sundingyi.com/blog/62/</link>
      <pubDate>Wed, 07 Apr 2021 20:23:22 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/62/</guid>
      <description>83 给定一个二进制数组， 计算其中最大连续 1 的个数。 示例： 输入：[1,1,0,1,1,1] 输出：3 解释：开头的两位和最后的三位都是连续 1 ，所以最</description>
    </item>
    
    <item>
      <title>每日LeetCode 79-82</title>
      <link>https://sundingyi.com/blog/61/</link>
      <pubDate>Tue, 06 Apr 2021 14:01:08 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/61/</guid>
      <description>79 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 *t* 由字符串 *s* 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例 1： 输入：</description>
    </item>
    
    <item>
      <title>每日LeetCode 76-78</title>
      <link>https://sundingyi.com/blog/60/</link>
      <pubDate>Mon, 05 Apr 2021 00:15:58 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/60/</guid>
      <description>76 猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数</description>
    </item>
    
    <item>
      <title>每日LeetCode 71-75</title>
      <link>https://sundingyi.com/blog/59/</link>
      <pubDate>Sun, 04 Apr 2021 12:21:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/59/</guid>
      <description>71 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须**原地修改输入数组</description>
    </item>
    
    <item>
      <title>每日LeetCode 67-70</title>
      <link>https://sundingyi.com/blog/58/</link>
      <pubDate>Sat, 03 Apr 2021 15:08:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/58/</guid>
      <description>67 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。 只有给定的树是单值二叉树时，才返回 true；否则返回 false。 输入：[1,</description>
    </item>
    
    <item>
      <title>每日LeetCode 65-66</title>
      <link>https://sundingyi.com/blog/57/</link>
      <pubDate>Fri, 02 Apr 2021 18:42:08 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/57/</guid>
      <description>65 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节</description>
    </item>
    
    <item>
      <title>每日LeetCode 61-64</title>
      <link>https://sundingyi.com/blog/56/</link>
      <pubDate>Thu, 01 Apr 2021 11:16:01 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/56/</guid>
      <description>61 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 进阶： 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决</description>
    </item>
    
    <item>
      <title>每日LeetCode 58-60</title>
      <link>https://sundingyi.com/blog/55/</link>
      <pubDate>Wed, 31 Mar 2021 10:46:53 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/55/</guid>
      <description>58 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例: 输入: 38 输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由</description>
    </item>
    
    <item>
      <title>每日LeetCode 56-57</title>
      <link>https://sundingyi.com/blog/54/</link>
      <pubDate>Tue, 30 Mar 2021 11:01:29 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/54/</guid>
      <description>56 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。 现有一个链表 &amp;ndash; head = [4,5,1,9]，它可</description>
    </item>
    
    <item>
      <title>每日LeetCode 53-55</title>
      <link>https://sundingyi.com/blog/53/</link>
      <pubDate>Mon, 29 Mar 2021 11:51:04 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/53/</guid>
      <description>53 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 输入: 1 输出: true 解释: 20 = 1 class Solution { public boolean isPowerOfTwo(int n) { if (n == 0) return false; long x = (long)n; return (x &amp;amp; -x) == x; } }</description>
    </item>
    
    <item>
      <title>每日LeetCode 49-52</title>
      <link>https://sundingyi.com/blog/52/</link>
      <pubDate>Sun, 28 Mar 2021 13:43:30 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/52/</guid>
      <description>49 给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1: 输入: [1,2,3,1]</description>
    </item>
    
    <item>
      <title>每日LeetCode 45-48</title>
      <link>https://sundingyi.com/blog/51/</link>
      <pubDate>Sat, 27 Mar 2021 15:24:26 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/51/</guid>
      <description>45 统计所有小于非负整数 n 的质数的数量。 示例 1： 输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 埃氏筛法：要得到自然数n以内</description>
    </item>
    
    <item>
      <title>每日LeetCode 40-44</title>
      <link>https://sundingyi.com/blog/50/</link>
      <pubDate>Fri, 26 Mar 2021 10:03:34 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/50/</guid>
      <description>40 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多</description>
    </item>
    
    <item>
      <title>每日LeetCode 38-39</title>
      <link>https://sundingyi.com/blog/49/</link>
      <pubDate>Thu, 25 Mar 2021 17:27:12 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/49/</guid>
      <description>38 给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 1 -&amp;gt; A 2 -&amp;gt; B 3 -&amp;gt; C ... 26 -&amp;gt; Z 27 -&amp;gt; AA 28 -&amp;gt; AB ... 示例 1: 输入: 1 输出: &amp;quot;A&amp;quot; class Solution { public String convertToTitle(int columnNumber) { StringBuilder ans = new</description>
    </item>
    
    <item>
      <title>每日LeetCode 37</title>
      <link>https://sundingyi.com/blog/48/</link>
      <pubDate>Wed, 24 Mar 2021 17:55:31 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/48/</guid>
      <description>37 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值</description>
    </item>
    
    <item>
      <title>每日LeetCode 36</title>
      <link>https://sundingyi.com/blog/47/</link>
      <pubDate>Tue, 23 Mar 2021 16:23:32 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/47/</guid>
      <description>36 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 **注</description>
    </item>
    
    <item>
      <title>每日LeetCode 35</title>
      <link>https://sundingyi.com/blog/46/</link>
      <pubDate>Mon, 22 Mar 2021 21:06:51 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/46/</guid>
      <description>35 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表**：** 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Re</description>
    </item>
    
    <item>
      <title>每日LeetCode 34</title>
      <link>https://sundingyi.com/blog/45/</link>
      <pubDate>Sun, 21 Mar 2021 12:58:08 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/45/</guid>
      <description>34 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整</description>
    </item>
    
    <item>
      <title>每日LeetCode 33</title>
      <link>https://sundingyi.com/blog/44/</link>
      <pubDate>Thu, 18 Mar 2021 12:23:39 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/44/</guid>
      <description>33 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计</description>
    </item>
    
    <item>
      <title>每日LeetCode 30-32</title>
      <link>https://sundingyi.com/blog/43/</link>
      <pubDate>Wed, 17 Mar 2021 17:55:13 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/43/</guid>
      <description>30 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 **说明：**叶子节点是指没有子节点的节点。 class Solution {</description>
    </item>
    
    <item>
      <title>每日LeetCode 29</title>
      <link>https://sundingyi.com/blog/42/</link>
      <pubDate>Tue, 16 Mar 2021 17:27:36 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/42/</guid>
      <description>29 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</description>
    </item>
    
    <item>
      <title>每日LeetCode 27-28</title>
      <link>https://sundingyi.com/blog/41/</link>
      <pubDate>Mon, 15 Mar 2021 15:44:33 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/41/</guid>
      <description>27 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉</description>
    </item>
    
    <item>
      <title>每日LeetCode 26</title>
      <link>https://sundingyi.com/blog/40/</link>
      <pubDate>Sun, 14 Mar 2021 21:09:33 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/40/</guid>
      <description>26 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4 4 3 class Solution { public boolean isSymmetric(TreeNode root) { return isMirror(root, root); } public boolean isMirror(TreeNode root, TreeNode root2) { if (root == null &amp;amp;&amp;amp;</description>
    </item>
    
    <item>
      <title>每日LeetCode 25</title>
      <link>https://sundingyi.com/blog/39/</link>
      <pubDate>Sat, 13 Mar 2021 15:21:44 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/39/</guid>
      <description>25 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1</description>
    </item>
    
    <item>
      <title>每日LeetCode 24</title>
      <link>https://sundingyi.com/blog/38/</link>
      <pubDate>Fri, 12 Mar 2021 19:20:13 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/38/</guid>
      <description>24 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中*，*使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大</description>
    </item>
    
    <item>
      <title>每日LeetCode 18-23</title>
      <link>https://sundingyi.com/blog/37/</link>
      <pubDate>Thu, 11 Mar 2021 10:40:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/37/</guid>
      <description>18 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子</description>
    </item>
    
    <item>
      <title>每日LeetCode 11-17</title>
      <link>https://sundingyi.com/blog/36/</link>
      <pubDate>Wed, 10 Mar 2021 12:51:00 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/36/</guid>
      <description>11 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式</description>
    </item>
    
    <item>
      <title>每日LeetCode 9-10</title>
      <link>https://sundingyi.com/blog/35/</link>
      <pubDate>Tue, 09 Mar 2021 16:00:04 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/35/</guid>
      <description>9 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写</description>
    </item>
    
    <item>
      <title>每日LeetCode 1-8</title>
      <link>https://sundingyi.com/blog/34/</link>
      <pubDate>Mon, 08 Mar 2021 08:43:45 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/34/</guid>
      <description>1 给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环</description>
    </item>
    
  </channel>
</rss>
