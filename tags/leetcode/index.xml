<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on 孙丁一的博客</title>
    <link>https://sundingyi.com/tags/leetcode/</link>
    <description>Recent content in LeetCode on 孙丁一的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 23 Mar 2021 16:23:32 +0800</lastBuildDate><atom:link href="https://sundingyi.com/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>每日LeetCode 36</title>
      <link>https://sundingyi.com/blog/47/</link>
      <pubDate>Tue, 23 Mar 2021 16:23:32 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/47/</guid>
      <description>36 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 **注</description>
    </item>
    
    <item>
      <title>每日LeetCode 35</title>
      <link>https://sundingyi.com/blog/46/</link>
      <pubDate>Mon, 22 Mar 2021 21:06:51 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/46/</guid>
      <description>35 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表**：** 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Re</description>
    </item>
    
    <item>
      <title>每日LeetCode 34</title>
      <link>https://sundingyi.com/blog/45/</link>
      <pubDate>Sun, 21 Mar 2021 12:58:08 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/45/</guid>
      <description>34 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整</description>
    </item>
    
    <item>
      <title>每日LeetCode 33</title>
      <link>https://sundingyi.com/blog/44/</link>
      <pubDate>Thu, 18 Mar 2021 12:23:39 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/44/</guid>
      <description>33 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计</description>
    </item>
    
    <item>
      <title>每日LeetCode 30-32</title>
      <link>https://sundingyi.com/blog/43/</link>
      <pubDate>Wed, 17 Mar 2021 17:55:13 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/43/</guid>
      <description>30 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 **说明：**叶子节点是指没有子节点的节点。 class Solution {</description>
    </item>
    
    <item>
      <title>每日LeetCode 29</title>
      <link>https://sundingyi.com/blog/42/</link>
      <pubDate>Tue, 16 Mar 2021 17:27:36 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/42/</guid>
      <description>29 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</description>
    </item>
    
    <item>
      <title>每日LeetCode 27-28</title>
      <link>https://sundingyi.com/blog/41/</link>
      <pubDate>Mon, 15 Mar 2021 15:44:33 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/41/</guid>
      <description>27 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉</description>
    </item>
    
    <item>
      <title>每日LeetCode 26</title>
      <link>https://sundingyi.com/blog/40/</link>
      <pubDate>Sun, 14 Mar 2021 21:09:33 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/40/</guid>
      <description>26 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4 4 3 class Solution { public boolean isSymmetric(TreeNode root) { return isMirror(root, root); } public boolean isMirror(TreeNode root, TreeNode root2) { if (root == null &amp;amp;&amp;amp;</description>
    </item>
    
    <item>
      <title>每日LeetCode 25</title>
      <link>https://sundingyi.com/blog/39/</link>
      <pubDate>Sat, 13 Mar 2021 15:21:44 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/39/</guid>
      <description>25 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1</description>
    </item>
    
    <item>
      <title>每日LeetCode 24</title>
      <link>https://sundingyi.com/blog/38/</link>
      <pubDate>Fri, 12 Mar 2021 19:20:13 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/38/</guid>
      <description>24 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中*，*使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大</description>
    </item>
    
    <item>
      <title>每日LeetCode 18-23</title>
      <link>https://sundingyi.com/blog/37/</link>
      <pubDate>Thu, 11 Mar 2021 10:40:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/37/</guid>
      <description>18 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子</description>
    </item>
    
    <item>
      <title>每日LeetCode 11-17</title>
      <link>https://sundingyi.com/blog/36/</link>
      <pubDate>Wed, 10 Mar 2021 12:51:00 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/36/</guid>
      <description>11 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式</description>
    </item>
    
    <item>
      <title>每日LeetCode 9-10</title>
      <link>https://sundingyi.com/blog/35/</link>
      <pubDate>Tue, 09 Mar 2021 16:00:04 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/35/</guid>
      <description>9 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写</description>
    </item>
    
    <item>
      <title>每日LeetCode 1-8</title>
      <link>https://sundingyi.com/blog/34/</link>
      <pubDate>Mon, 08 Mar 2021 08:43:45 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/34/</guid>
      <description>1 给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环</description>
    </item>
    
  </channel>
</rss>
