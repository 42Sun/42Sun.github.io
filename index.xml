<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>孙丁一的博客</title>
    <link>https://sundingyi.com/</link>
    <description>Recent content on 孙丁一的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 24 May 2021 21:47:48 +0800</lastBuildDate><atom:link href="https://sundingyi.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>照片</title>
      <link>https://sundingyi.com/projects/photography/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sundingyi.com/projects/photography/</guid>
      <description></description>
    </item>
    
    <item>
      <title>画</title>
      <link>https://sundingyi.com/projects/design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sundingyi.com/projects/design/</guid>
      <description></description>
    </item>
    
    <item>
      <title>每日LeetCode 179-180</title>
      <link>https://sundingyi.com/blog/97/</link>
      <pubDate>Mon, 24 May 2021 21:47:48 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/97/</guid>
      <description>179 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: MinStack minStack =</description>
    </item>
    
    <item>
      <title>每日LeetCode 178</title>
      <link>https://sundingyi.com/blog/96/</link>
      <pubDate>Tue, 18 May 2021 22:00:11 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/96/</guid>
      <description>178 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / 2 2 / \ / 3 4 4</description>
    </item>
    
    <item>
      <title>每日LeetCode 176-177</title>
      <link>https://sundingyi.com/blog/95/</link>
      <pubDate>Sun, 16 May 2021 19:28:47 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/95/</guid>
      <description>176 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:</description>
    </item>
    
    <item>
      <title>每日LeetCode 173-175</title>
      <link>https://sundingyi.com/blog/94/</link>
      <pubDate>Sat, 15 May 2021 13:00:04 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/94/</guid>
      <description>173 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例： 输入：nums =</description>
    </item>
    
    <item>
      <title>每日LeetCode 171-172</title>
      <link>https://sundingyi.com/blog/93/</link>
      <pubDate>Fri, 14 May 2021 20:55:53 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/93/</guid>
      <description>171 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1: 输入: n = 1 输出: [1,2,3,4,5,6,7,8,9] 来源：</description>
    </item>
    
    <item>
      <title>每日LeetCode 169-170</title>
      <link>https://sundingyi.com/blog/92/</link>
      <pubDate>Thu, 13 May 2021 21:25:28 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/92/</guid>
      <description>169 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入</description>
    </item>
    
    <item>
      <title>每日LeetCode 166-168</title>
      <link>https://sundingyi.com/blog/91/</link>
      <pubDate>Tue, 11 May 2021 17:18:07 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/91/</guid>
      <description>166 09 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素</description>
    </item>
    
    <item>
      <title>每日LeetCode 163-165</title>
      <link>https://sundingyi.com/blog/90/</link>
      <pubDate>Mon, 10 May 2021 15:58:03 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/90/</guid>
      <description>163 剑指offer 05 请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。 示例 1： 输入：s = &amp;ldquo;We are happy.&amp;rdquo; 输出：&amp;ldquo;W</description>
    </item>
    
    <item>
      <title>每日LeetCode 160-162</title>
      <link>https://sundingyi.com/blog/89/</link>
      <pubDate>Sat, 08 May 2021 17:46:42 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/89/</guid>
      <description>160 (剑指 offer 11) 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如</description>
    </item>
    
    <item>
      <title>每日LeetCode 158-159</title>
      <link>https://sundingyi.com/blog/88/</link>
      <pubDate>Fri, 07 May 2021 19:47:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/88/</guid>
      <description>158 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： &#39;A&#39; -&amp;gt; 1 &#39;B&#39; -&amp;gt; 2 ... &#39;Z&#39; -&amp;gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有</description>
    </item>
    
    <item>
      <title>每日LeetCode 156-157</title>
      <link>https://sundingyi.com/blog/87/</link>
      <pubDate>Thu, 06 May 2021 15:43:02 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/87/</guid>
      <description>156 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构</description>
    </item>
    
    <item>
      <title>每日LeetCode 152-155</title>
      <link>https://sundingyi.com/blog/86/</link>
      <pubDate>Wed, 05 May 2021 20:18:34 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/86/</guid>
      <description>152 给定两个整数 n 和 k，返回 1 &amp;hellip; n 中所有可能的 k 个数的组合。 示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(int n, int k) { getCombine(n, k, 1,</description>
    </item>
    
    <item>
      <title>每日LeetCode 151</title>
      <link>https://sundingyi.com/blog/85/</link>
      <pubDate>Tue, 04 May 2021 19:57:03 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/85/</guid>
      <description>151 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的</description>
    </item>
    
    <item>
      <title>每日LeetCode 150</title>
      <link>https://sundingyi.com/blog/84/</link>
      <pubDate>Mon, 03 May 2021 21:07:11 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/84/</guid>
      <description>150 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题</description>
    </item>
    
    <item>
      <title>每日LeetCode 149</title>
      <link>https://sundingyi.com/blog/149/</link>
      <pubDate>Sun, 02 May 2021 20:24:36 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/149/</guid>
      <description>149 给定一个 *m* x *n* 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法**。** 进阶： 一个直观的解决方案是使用 O(*m**n*) 的额外</description>
    </item>
    
    <item>
      <title>每日LeetCode 148</title>
      <link>https://sundingyi.com/blog/82/</link>
      <pubDate>Sat, 01 May 2021 20:20:03 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/82/</guid>
      <description>148 给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 **说明：**每次只能向下或者向右移动一</description>
    </item>
    
    <item>
      <title>每日LeetCode 147</title>
      <link>https://sundingyi.com/blog/81/</link>
      <pubDate>Fri, 30 Apr 2021 21:21:09 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/81/</guid>
      <description>147 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角</description>
    </item>
    
    <item>
      <title>每日LeetCode 146</title>
      <link>https://sundingyi.com/blog/80/</link>
      <pubDate>Thu, 29 Apr 2021 20:08:24 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/80/</guid>
      <description>146 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角</description>
    </item>
    
    <item>
      <title>每日LeetCode 143-145</title>
      <link>https://sundingyi.com/blog/79/</link>
      <pubDate>Wed, 28 Apr 2021 17:01:21 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/79/</guid>
      <description>143 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。 如果不能形成任何面积不为零的三角形，返回 0</description>
    </item>
    
    <item>
      <title>每日LeetCode 140-142</title>
      <link>https://sundingyi.com/blog/78/</link>
      <pubDate>Sat, 24 Apr 2021 22:48:43 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/78/</guid>
      <description>140 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以</description>
    </item>
    
    <item>
      <title>每日LeetCode 137-139</title>
      <link>https://sundingyi.com/blog/77/</link>
      <pubDate>Fri, 23 Apr 2021 20:33:00 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/77/</guid>
      <description>137 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 class Solution { int pre; int ans; public int minDiffInBST(TreeNode root) { ans = Integer.MAX_VALUE; pre = -1; dfs(root); return ans; } public void dfs(TreeNode root ){ if (root == null) { return; }</description>
    </item>
    
    <item>
      <title>每日LeetCode 133-136</title>
      <link>https://sundingyi.com/blog/76/</link>
      <pubDate>Wed, 21 Apr 2021 15:50:13 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/76/</guid>
      <description>133 给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。 重复出现的子串要计算它</description>
    </item>
    
    <item>
      <title>每日LeetCode 130-132</title>
      <link>https://sundingyi.com/blog/75/</link>
      <pubDate>Mon, 19 Apr 2021 21:03:25 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/75/</guid>
      <description>130 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节</description>
    </item>
    
    <item>
      <title>每日LeetCode 126-129</title>
      <link>https://sundingyi.com/blog/74/</link>
      <pubDate>Sun, 18 Apr 2021 13:37:03 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/74/</guid>
      <description>126 给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果</description>
    </item>
    
    <item>
      <title>SpringAOP</title>
      <link>https://sundingyi.com/blog/73/</link>
      <pubDate>Sat, 17 Apr 2021 15:12:22 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/73/</guid>
      <description>Aspect Oriented Programing 面向切面编程 代理模式 为某一个对象（委托类）准备一个代理（代理类），用来控制对这个对象的访问。 两者有一个共同的父类或父接口。 代理类会对请</description>
    </item>
    
    <item>
      <title>每日LeetCode 122-125</title>
      <link>https://sundingyi.com/blog/72/</link>
      <pubDate>Sat, 17 Apr 2021 12:22:17 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/72/</guid>
      <description>122 你和你的朋友，两个人一起玩 Nim 游戏： 桌子上有一堆石头。 你们轮流进行自己的回合，你作为先手。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石</description>
    </item>
    
    <item>
      <title>每日LeetCode 118-121</title>
      <link>https://sundingyi.com/blog/71/</link>
      <pubDate>Fri, 16 Apr 2021 19:05:10 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/71/</guid>
      <description>118 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 示例 1： 输入： 3 / \ 9 20 / \ 15 7 输出：[3, 14.5, 11] 解释： 第 0 层的平均值是 3 , 第1层是</description>
    </item>
    
    <item>
      <title>Spring IOC</title>
      <link>https://sundingyi.com/blog/70/</link>
      <pubDate>Fri, 16 Apr 2021 18:46:00 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/70/</guid>
      <description>Inversion of Control 控制反转 配置文件 引入配置文件的方法的参数可以多个。 在一个总的配置文件中用 &amp;lt;import resource=&amp;quot;xx.xml&amp;quot;/&amp;gt; 进行引用。 IOC 注入 set 方法注入 P 标签注入 在 Spring 2.5 之后，为了 set 注入</description>
    </item>
    
    <item>
      <title>每日LeetCode 114-117</title>
      <link>https://sundingyi.com/blog/69/</link>
      <pubDate>Thu, 15 Apr 2021 14:04:46 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/69/</guid>
      <description>114 假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索</description>
    </item>
    
    <item>
      <title>每日LeetCode 110-113</title>
      <link>https://sundingyi.com/blog/68/</link>
      <pubDate>Wed, 14 Apr 2021 19:20:12 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/68/</guid>
      <description>110 给定一个 N 叉树，返回其节点值的 后序遍历 。 N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 递归 class Solution { public List&amp;lt;Integer&amp;gt; postorder(Node root) {</description>
    </item>
    
    <item>
      <title>每日LeetCode 107-109</title>
      <link>https://sundingyi.com/blog/67/</link>
      <pubDate>Mon, 12 Apr 2021 21:23:10 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/67/</guid>
      <description>107 你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。 给定一个数字 n，找出可形成完整阶梯行的总行数。 n 是一个非负整数</description>
    </item>
    
    <item>
      <title>每日LeetCode 103-106</title>
      <link>https://sundingyi.com/blog/66/</link>
      <pubDate>Sun, 11 Apr 2021 18:11:56 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/66/</guid>
      <description>103 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结</description>
    </item>
    
    <item>
      <title>每日LeetCode 99-102</title>
      <link>https://sundingyi.com/blog/65/</link>
      <pubDate>Sat, 10 Apr 2021 18:52:18 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/65/</guid>
      <description>99 给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符： &amp;lsquo;A&amp;rsquo; : Absent，缺勤 &amp;lsquo;L&amp;rsquo; : Late，迟到 &amp;lsquo;P&amp;rsquo; : Present，到场 如果一</description>
    </item>
    
    <item>
      <title>每日LeetCode 94-98</title>
      <link>https://sundingyi.com/blog/64/</link>
      <pubDate>Fri, 09 Apr 2021 20:03:17 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/64/</guid>
      <description>94 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入</description>
    </item>
    
    <item>
      <title>每日LeetCode 88-93</title>
      <link>https://sundingyi.com/blog/63/</link>
      <pubDate>Thu, 08 Apr 2021 20:12:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/63/</guid>
      <description>88 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) =</description>
    </item>
    
    <item>
      <title>每日LeetCode 83-87</title>
      <link>https://sundingyi.com/blog/62/</link>
      <pubDate>Wed, 07 Apr 2021 20:23:22 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/62/</guid>
      <description>83 给定一个二进制数组， 计算其中最大连续 1 的个数。 示例： 输入：[1,1,0,1,1,1] 输出：3 解释：开头的两位和最后的三位都是连续 1 ，所以最</description>
    </item>
    
    <item>
      <title>每日LeetCode 79-82</title>
      <link>https://sundingyi.com/blog/61/</link>
      <pubDate>Tue, 06 Apr 2021 14:01:08 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/61/</guid>
      <description>79 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 *t* 由字符串 *s* 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例 1： 输入：</description>
    </item>
    
    <item>
      <title>每日LeetCode 76-78</title>
      <link>https://sundingyi.com/blog/60/</link>
      <pubDate>Mon, 05 Apr 2021 00:15:58 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/60/</guid>
      <description>76 猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数</description>
    </item>
    
    <item>
      <title>每日LeetCode 71-75</title>
      <link>https://sundingyi.com/blog/59/</link>
      <pubDate>Sun, 04 Apr 2021 12:21:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/59/</guid>
      <description>71 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须**原地修改输入数组</description>
    </item>
    
    <item>
      <title>每日LeetCode 67-70</title>
      <link>https://sundingyi.com/blog/58/</link>
      <pubDate>Sat, 03 Apr 2021 15:08:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/58/</guid>
      <description>67 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。 只有给定的树是单值二叉树时，才返回 true；否则返回 false。 输入：[1,</description>
    </item>
    
    <item>
      <title>每日LeetCode 65-66</title>
      <link>https://sundingyi.com/blog/57/</link>
      <pubDate>Fri, 02 Apr 2021 18:42:08 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/57/</guid>
      <description>65 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节</description>
    </item>
    
    <item>
      <title>每日LeetCode 61-64</title>
      <link>https://sundingyi.com/blog/56/</link>
      <pubDate>Thu, 01 Apr 2021 11:16:01 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/56/</guid>
      <description>61 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 进阶： 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决</description>
    </item>
    
    <item>
      <title>每日LeetCode 58-60</title>
      <link>https://sundingyi.com/blog/55/</link>
      <pubDate>Wed, 31 Mar 2021 10:46:53 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/55/</guid>
      <description>58 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例: 输入: 38 输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由</description>
    </item>
    
    <item>
      <title>每日LeetCode 56-57</title>
      <link>https://sundingyi.com/blog/54/</link>
      <pubDate>Tue, 30 Mar 2021 11:01:29 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/54/</guid>
      <description>56 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。 现有一个链表 &amp;ndash; head = [4,5,1,9]，它可</description>
    </item>
    
    <item>
      <title>每日LeetCode 53-55</title>
      <link>https://sundingyi.com/blog/53/</link>
      <pubDate>Mon, 29 Mar 2021 11:51:04 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/53/</guid>
      <description>53 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 输入: 1 输出: true 解释: 20 = 1 class Solution { public boolean isPowerOfTwo(int n) { if (n == 0) return false; long x = (long)n; return (x &amp;amp; -x) == x; } }</description>
    </item>
    
    <item>
      <title>每日LeetCode 49-52</title>
      <link>https://sundingyi.com/blog/52/</link>
      <pubDate>Sun, 28 Mar 2021 13:43:30 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/52/</guid>
      <description>49 给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1: 输入: [1,2,3,1]</description>
    </item>
    
    <item>
      <title>每日LeetCode 45-48</title>
      <link>https://sundingyi.com/blog/51/</link>
      <pubDate>Sat, 27 Mar 2021 15:24:26 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/51/</guid>
      <description>45 统计所有小于非负整数 n 的质数的数量。 示例 1： 输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 埃氏筛法：要得到自然数n以内</description>
    </item>
    
    <item>
      <title>每日LeetCode 40-44</title>
      <link>https://sundingyi.com/blog/50/</link>
      <pubDate>Fri, 26 Mar 2021 10:03:34 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/50/</guid>
      <description>40 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多</description>
    </item>
    
    <item>
      <title>每日LeetCode 38-39</title>
      <link>https://sundingyi.com/blog/49/</link>
      <pubDate>Thu, 25 Mar 2021 17:27:12 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/49/</guid>
      <description>38 给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 1 -&amp;gt; A 2 -&amp;gt; B 3 -&amp;gt; C ... 26 -&amp;gt; Z 27 -&amp;gt; AA 28 -&amp;gt; AB ... 示例 1: 输入: 1 输出: &amp;quot;A&amp;quot; class Solution { public String convertToTitle(int columnNumber) { StringBuilder ans = new</description>
    </item>
    
    <item>
      <title>每日LeetCode 37</title>
      <link>https://sundingyi.com/blog/48/</link>
      <pubDate>Wed, 24 Mar 2021 17:55:31 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/48/</guid>
      <description>37 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值</description>
    </item>
    
    <item>
      <title>每日LeetCode 36</title>
      <link>https://sundingyi.com/blog/47/</link>
      <pubDate>Tue, 23 Mar 2021 16:23:32 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/47/</guid>
      <description>36 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 **注</description>
    </item>
    
    <item>
      <title>每日LeetCode 35</title>
      <link>https://sundingyi.com/blog/46/</link>
      <pubDate>Mon, 22 Mar 2021 21:06:51 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/46/</guid>
      <description>35 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表**：** 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Re</description>
    </item>
    
    <item>
      <title>每日LeetCode 34</title>
      <link>https://sundingyi.com/blog/45/</link>
      <pubDate>Sun, 21 Mar 2021 12:58:08 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/45/</guid>
      <description>34 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整</description>
    </item>
    
    <item>
      <title>每日LeetCode 33</title>
      <link>https://sundingyi.com/blog/44/</link>
      <pubDate>Thu, 18 Mar 2021 12:23:39 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/44/</guid>
      <description>33 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计</description>
    </item>
    
    <item>
      <title>每日LeetCode 30-32</title>
      <link>https://sundingyi.com/blog/43/</link>
      <pubDate>Wed, 17 Mar 2021 17:55:13 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/43/</guid>
      <description>30 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 **说明：**叶子节点是指没有子节点的节点。 class Solution {</description>
    </item>
    
    <item>
      <title>每日LeetCode 29</title>
      <link>https://sundingyi.com/blog/42/</link>
      <pubDate>Tue, 16 Mar 2021 17:27:36 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/42/</guid>
      <description>29 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</description>
    </item>
    
    <item>
      <title>每日LeetCode 27-28</title>
      <link>https://sundingyi.com/blog/41/</link>
      <pubDate>Mon, 15 Mar 2021 15:44:33 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/41/</guid>
      <description>27 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉</description>
    </item>
    
    <item>
      <title>每日LeetCode 26</title>
      <link>https://sundingyi.com/blog/40/</link>
      <pubDate>Sun, 14 Mar 2021 21:09:33 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/40/</guid>
      <description>26 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4 4 3 class Solution { public boolean isSymmetric(TreeNode root) { return isMirror(root, root); } public boolean isMirror(TreeNode root, TreeNode root2) { if (root == null &amp;amp;&amp;amp;</description>
    </item>
    
    <item>
      <title>每日LeetCode 25</title>
      <link>https://sundingyi.com/blog/39/</link>
      <pubDate>Sat, 13 Mar 2021 15:21:44 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/39/</guid>
      <description>25 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1</description>
    </item>
    
    <item>
      <title>每日LeetCode 24</title>
      <link>https://sundingyi.com/blog/38/</link>
      <pubDate>Fri, 12 Mar 2021 19:20:13 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/38/</guid>
      <description>24 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中*，*使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大</description>
    </item>
    
    <item>
      <title>每日LeetCode 18-23</title>
      <link>https://sundingyi.com/blog/37/</link>
      <pubDate>Thu, 11 Mar 2021 10:40:49 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/37/</guid>
      <description>18 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子</description>
    </item>
    
    <item>
      <title>每日LeetCode 11-17</title>
      <link>https://sundingyi.com/blog/36/</link>
      <pubDate>Wed, 10 Mar 2021 12:51:00 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/36/</guid>
      <description>11 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式</description>
    </item>
    
    <item>
      <title>每日LeetCode 9-10</title>
      <link>https://sundingyi.com/blog/35/</link>
      <pubDate>Tue, 09 Mar 2021 16:00:04 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/35/</guid>
      <description>9 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写</description>
    </item>
    
    <item>
      <title>每日LeetCode 1-8</title>
      <link>https://sundingyi.com/blog/34/</link>
      <pubDate>Mon, 08 Mar 2021 08:43:45 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/34/</guid>
      <description>1 给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环</description>
    </item>
    
    <item>
      <title>《群魔》与虚无主义</title>
      <link>https://sundingyi.com/blog/33/</link>
      <pubDate>Thu, 04 Feb 2021 17:20:06 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/33/</guid>
      <description>陀思妥耶夫斯基著作《群魔》，阅读时间为 2020 年 12 月 10 日至 2021 年 2 月 3 日，拖沓这么久主要还是因为中途直接和考试发生对撞，导致我根本没心思读要考试的书</description>
    </item>
    
    <item>
      <title>现代和弦代号</title>
      <link>https://sundingyi.com/blog/32/</link>
      <pubDate>Fri, 29 Jan 2021 18:22:10 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/32/</guid>
      <description>三和弦（triad） 由三个音组成的和弦。 七和弦（seventh chord） 由四个音组成的和弦。 九和弦（ninth chord） 由五个音组成的和</description>
    </item>
    
    <item>
      <title>和Notion，讲讲我的记录方式</title>
      <link>https://sundingyi.com/blog/31/</link>
      <pubDate>Sun, 20 Dec 2020 15:34:48 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/31/</guid>
      <description>我是个很喜欢产品的人，无论是硬件和软件都令我着迷，给予晶体管和代码以生命是件浪漫的事。 最近，我开始了解 Notion，开始使用 Notion，并</description>
    </item>
    
    <item>
      <title>Java 正则表达式</title>
      <link>https://sundingyi.com/blog/30/</link>
      <pubDate>Sat, 12 Dec 2020 17:32:13 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/30/</guid>
      <description>字符串是一个非常万能的类型，它不仅仅可以进行修改，还可以向各个数据类型进行转换，用户输入的信息基本上都用字符串接收。于是在向其他数据类型转换</description>
    </item>
    
    <item>
      <title>Java 常用基础类库</title>
      <link>https://sundingyi.com/blog/29/</link>
      <pubDate>Thu, 10 Dec 2020 22:06:53 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/29/</guid>
      <description>StringBuffer 类 每一个字符串的常量都属于一个 String 类的匿名对象，不可更改。 String 有两个常量池：静态常量池、运行时常量池。 String 类对象实例化建议使用直接赋值的方式完成</description>
    </item>
    
    <item>
      <title>深入多线程</title>
      <link>https://sundingyi.com/blog/28/</link>
      <pubDate>Tue, 08 Dec 2020 10:41:47 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/28/</guid>
      <description>停止线程 在多线程的操作之中，大多数情况下使用的是Thread的start()，如果对于多线程需要进行停止处理，Thread提供有stop()</description>
    </item>
    
    <item>
      <title>生产者消费者基本模型</title>
      <link>https://sundingyi.com/blog/27/</link>
      <pubDate>Tue, 08 Dec 2020 10:41:38 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/27/</guid>
      <description>模型概述 在多线程开发之中，最为著名的案例就是生产者与消费者操作。 流程 生产者负责信息内容的生产。 每当生产者完成一项完整的信息之后，消费者则取走</description>
    </item>
    
    <item>
      <title>多线程同步与死锁</title>
      <link>https://sundingyi.com/blog/26/</link>
      <pubDate>Sun, 06 Dec 2020 16:04:14 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/26/</guid>
      <description>线程同步 在多线程的处理过程之中，可以利用 Runnable 描述多个线程操作的资源，在在描述这些资源的时候，如果处理不当就会产生数据的错误操作。 引出 一个简单的</description>
    </item>
    
    <item>
      <title>多线程常用操作方法</title>
      <link>https://sundingyi.com/blog/25/</link>
      <pubDate>Sat, 05 Dec 2020 19:17:37 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/25/</guid>
      <description>多线程的常用方法大多都在 Thread 类中定义了。 线程的命名与取得 多线程的运行状态是不确定的，如果想要获取到某一个特定的线程，就需要通过线程的名字来进行</description>
    </item>
    
    <item>
      <title>Java 多线程基础</title>
      <link>https://sundingyi.com/blog/24/</link>
      <pubDate>Fri, 04 Dec 2020 21:25:46 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/24/</guid>
      <description>Java 支持多线程开发。在进行并发访问处理时可得到更高的处理性能。 进程：DOS 采用单进程处理，最大的特点就是同一个时间，只运行一个程序。Windo</description>
    </item>
    
    <item>
      <title>2020数字生活总结</title>
      <link>https://sundingyi.com/blog/23/</link>
      <pubDate>Wed, 02 Dec 2020 21:49:15 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/23/</guid>
      <description>Spotify 2019 2020</description>
    </item>
    
    <item>
      <title>TSP问题简单讨论</title>
      <link>https://sundingyi.com/blog/22/</link>
      <pubDate>Mon, 30 Nov 2020 18:38:32 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/22/</guid>
      <description>（本文为latex转markdown生成） 图在计算机中如何表示 邻接表 邻接表是一个链表的集合，链表的表头表示一个节点。比较适合存储稀疏的图。 例</description>
    </item>
    
    <item>
      <title>最简单的单向链表实现</title>
      <link>https://sundingyi.com/blog/21/</link>
      <pubDate>Mon, 30 Nov 2020 18:22:36 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/21/</guid>
      <description>interface ILink&amp;lt;E&amp;gt; { public void add(E e); public int size(); public boolean isEmpty(); public Object[] toArray(); public E get(int index); public void set(int index, E data); public boolean contains(E data); public void remove(E data); public void clean(); } class LinkImpl&amp;lt;E&amp;gt; implements ILink&amp;lt;E&amp;gt; { private class Node { private E data; private Node next; public Node(E data) { this.data = data; } public void addNode(Node newNode) { if (this.next == null)</description>
    </item>
    
    <item>
      <title>Java中关于String的常用方法</title>
      <link>https://sundingyi.com/blog/20/</link>
      <pubDate>Sat, 21 Nov 2020 18:51:45 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/20/</guid>
      <description>String和char[]之间常用 方法 描述 public String(char[] value) 把传入的字符数组变为字符串 public String(char[] value, int offset, int count) offset表示开始的位置，count表示个数 public char charAt(int</description>
    </item>
    
    <item>
      <title>OneNote的两个讨厌问题解决</title>
      <link>https://sundingyi.com/blog/19/</link>
      <pubDate>Sat, 21 Nov 2020 00:41:07 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/19/</guid>
      <description>强大的微软在开开心心的周五晚上毁了我的心情😠 OneNote的录音（音频）播放在蓝牙耳机下无法工作 问题复现 我的蓝牙耳机有两个连接模式：Hand</description>
    </item>
    
    <item>
      <title>Practice4</title>
      <link>https://sundingyi.com/blog/18/</link>
      <pubDate>Tue, 03 Nov 2020 14:27:43 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/18/</guid>
      <description>编写一个类A，该类创建的对象可以调用方法f输出小写的英文字母表。然后再编写一个A类的子类B，要求子类B必须继承类A的方法f（不允许重写），子</description>
    </item>
    
    <item>
      <title>Practice3</title>
      <link>https://sundingyi.com/blog/17/</link>
      <pubDate>Sun, 18 Oct 2020 10:16:43 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/17/</guid>
      <description>学生类（Student）:属性：姓名、年龄、数学成绩、英语成绩；方法：构造函数（初始化姓名和年龄），设置成绩，求均分；子类（Newstude</description>
    </item>
    
    <item>
      <title>Practice2</title>
      <link>https://sundingyi.com/blog/16/</link>
      <pubDate>Fri, 09 Oct 2020 13:04:36 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/16/</guid>
      <description>public class Test1 { public static void main(String[] args) { int[][] a = new int[][] { {1, 2, 3, 4, 5}, {1, 2, 3, 4, 5}, {1, 2, 3, 4, 5}, {1, 2, 3, 4, 5}, {1, 2, 3, 4, 5} }; for (int[] b : a) { for (int c : b) { System.out.println(c); } } } } public class Test2 { public static void main(String[] args) { for</description>
    </item>
    
    <item>
      <title>排序</title>
      <link>https://sundingyi.com/blog/15/</link>
      <pubDate>Wed, 07 Oct 2020 17:58:04 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/15/</guid>
      <description>选择排序 public class P { public static void selectionSort(int[] arr) { for (int i = 0; i &amp;lt; arr.length - 1; ++i) { int temp = arr[i]; int flag = i; for (int j = i + 1; j &amp;lt; arr.length; ++j) { if (arr[j] &amp;lt; temp) { temp = arr[j]; flag = j; } } if (i != flag) { arr[flag] = arr[i]; arr[i] = temp;</description>
    </item>
    
    <item>
      <title>Practice1</title>
      <link>https://sundingyi.com/blog/14/</link>
      <pubDate>Tue, 29 Sep 2020 16:49:06 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/14/</guid>
      <description>2020/10/4 待交 //9 import java.util.Scanner; public class Test { public static void main(String[] args) { Scanner input = new Scanner(System.in); int[] arr = new int[10]; for (int i = 0; i &amp;lt; 10; ++i) { arr[i] = input.nextInt(); } int max = arr[0]; int min = arr[0]; for (int i = 0; i &amp;lt; 10; ++i) { if (arr[i] &amp;gt; max) max = arr[i]; if (arr[i] &amp;lt; min) min</description>
    </item>
    
    <item>
      <title>算法第一章习题记录</title>
      <link>https://sundingyi.com/blog/13/</link>
      <pubDate>Mon, 28 Sep 2020 20:23:42 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/13/</guid>
      <description>算法（第4版）作者: 塞奇威克 (Robert Sedgewick) / 韦恩 (Kevin Wayne) 第一章课后习题 //1.1.3 import java.util.Scanner; public class Test { public static void main(String[] args) { Scanner input = new Scanner(System.in); int a = input.nextInt(); int b = input.nextInt(); int c = input.nextInt(); if (a == b &amp;amp;&amp;amp; b == c) { System.out.println(&amp;#34;equal&amp;#34;); } else</description>
    </item>
    
    <item>
      <title>阅读摘抄（长期更新）</title>
      <link>https://sundingyi.com/blog/12/</link>
      <pubDate>Fri, 03 Jul 2020 15:03:40 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/12/</guid>
      <description>杨路：疫情阴影下的中美脱钩前景——有所缓和还是加速分离？｜端傳媒 Initium Media March 30, 2020 中国二月份公布的官方制造业采购经理人指数（PMI）是35.7，而非</description>
    </item>
    
    <item>
      <title>字符串和常用数据结构</title>
      <link>https://sundingyi.com/blog/11/</link>
      <pubDate>Sun, 28 Jun 2020 18:28:15 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/11/</guid>
      <description>字符串 字符串是由零个或多个字符组成的有限序列。在Python中，用&#39;&#39;或&amp;quot;&amp;quot;将一个或多个字符包含起来就可以表示一个字符串</description>
    </item>
    
    <item>
      <title>函数和模块</title>
      <link>https://sundingyi.com/blog/10/</link>
      <pubDate>Sun, 28 Jun 2020 15:53:03 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/10/</guid>
      <description>函数 将某一个功能封装到函数中。需要这个功能的时候只需要调用这个函数就可以了。 可以不传入参数。 定义函数 使用def关键字来定义函数，函数的命名和</description>
    </item>
    
    <item>
      <title>Python基础</title>
      <link>https://sundingyi.com/blog/9/</link>
      <pubDate>Sat, 27 Jun 2020 14:19:44 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/9/</guid>
      <description>Python历史 1989年圣诞节：Guido von Rossum开始写Python语言的编译器。 1991年2月：第一个Python编译器（同时也是</description>
    </item>
    
    <item>
      <title>评论/留言区上线</title>
      <link>https://sundingyi.com/blog/8/</link>
      <pubDate>Fri, 19 Jun 2020 22:36:47 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/8/</guid>
      <description>可真的会有人在里面写东西吗 hugo使用评论区已经有几套成熟的方案了，我选择的是utterances+github的方式，不需要后端配合。 建立</description>
    </item>
    
    <item>
      <title>当我们在评论《切尔诺贝利》时我们在谈论什么</title>
      <link>https://sundingyi.com/blog/82fbce2c/</link>
      <pubDate>Mon, 20 Apr 2020 02:25:03 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/82fbce2c/</guid>
      <description>最近一周在读S.A.阿列克谢耶维奇的《我不知道该说什么，关于死亡还是爱情》，一本采访集，讲述的是切尔诺贝利事件的亲历者所感所想，所到之处皆是</description>
    </item>
    
    <item>
      <title>Git笔记</title>
      <link>https://sundingyi.com/blog/7/</link>
      <pubDate>Thu, 09 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://sundingyi.com/blog/7/</guid>
      <description>git是这个世界上目前最先进的分布式版本控制系统。 千万不要使用Windows自带的记事本编辑任何文本文件。 创建版本库 mkdir 是创建文件夹的命令， pwd</description>
    </item>
    
    <item>
      <title>语雀作为在线平台同步hugo</title>
      <link>https://sundingyi.com/blog/6/</link>
      <pubDate>Mon, 09 Mar 2020 16:43:15 +0000</pubDate>
      
      <guid>https://sundingyi.com/blog/6/</guid>
      <description>第一次接触语雀是在去年，当时在找一个靠谱的在线笔记编辑平台，听闻是阿里出品的，后来实际接触感觉还不错。支持Markdown很舒服。 同步语雀的</description>
    </item>
    
    <item>
      <title>有意思的一个转场</title>
      <link>https://sundingyi.com/blog/5/</link>
      <pubDate>Thu, 06 Feb 2020 21:00:55 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/5/</guid>
      <description>S03E08 眼前一亮的感觉，反复看了几遍，发现拍摄手法比我想象的简单多了&amp;hellip; 至于为什么看出来了？Joel跑完属实有点喘</description>
    </item>
    
    <item>
      <title>我抬起了头，却满是坟墓</title>
      <link>https://sundingyi.com/blog/4/</link>
      <pubDate>Mon, 04 Nov 2019 21:27:11 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/4/</guid>
      <description>跑完步了，戴着耳机享受下和自己相处，天气转凉以来身体明显没有夏天时候好了，呼吸到冷空气都会很难受，这几十年，原本就是个折腾的过程。一条路一条</description>
    </item>
    
    <item>
      <title>原来我创造了世界</title>
      <link>https://sundingyi.com/blog/3/</link>
      <pubDate>Sat, 02 Nov 2019 00:22:31 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/3/</guid>
      <description>科幻作品我看过和读过不少，上一次读过的是《深渊上的火》，隔了几个月，我刚刚读完了小林泰三的《玩具修理者》和《醉步男》。 很震惊的说，我已经很久</description>
    </item>
    
    <item>
      <title>什么是哥白尼哲学抑郁</title>
      <link>https://sundingyi.com/blog/1/</link>
      <pubDate>Sun, 27 Oct 2019 19:11:16 +0800</pubDate>
      
      <guid>https://sundingyi.com/blog/1/</guid>
      <description>极简宇宙史 这是我最近正在阅读的一本书，特别值得推崇的是全书中只有E = mc^2这么一个简洁的公式，而且行文也易懂，我还是忘不了多次被我多次中途</description>
    </item>
    
  </channel>
</rss>
